---
title:  "99클럽 코테 스터디 3일차 TIL + 이분탐색"
excerpt: "1월 14일 학습 기록"

writer: 1303sari

categories:
  - 항해99 코딩 테스트 스터디
tags:
  - [Algorithm, CodingTest, Python, 99클럽, 코딩테스트준비, 개발자취업, 항해99, TIL]

toc: true
toc_sticky: true
 
date: 2025-01-15
last_modified_at: 2025-01-15
---

오늘의 코딩 테스트 알고리즘도 지난번에 복습했던 이분탐색에 관한 알고리즘이었기 때문에 오늘은 시간복잡도에 대해 공부해봤다.

시간 복잡도(Time Complexity)는 알고리즘의 효율성을 측정하는 중요한 개념이다. 알고리즘의 성능을 평가할 때, 실행 시간이 입력 크기에 따라 어떻게 변하는지를 나타내며, 이를 통해 최적화 가능한 부분을 찾아낼 수 있다.

## 1. 시간 복잡도란?
시간 복잡도는 알고리즘이 실행되는 데 걸리는 시간을 입력 데이터의 크기 𝑛에 대해 나타내는 함수다. 즉, 시간 복잡도는 알고리즘이 얼마나 효율적으로 동작하는지, 입력 크기가 커질수록 성능이 어떻게 변화하는지를 보여준다.

ex - 주어진 배열에서 특정 값을 찾는 알고리즘
배열의 크기가 커질수록 알고리즘이 처리해야 하는 연산 횟수도 어떻게 변하는지를 나타내는 것이 시간 복잡도

## 2. 시간 복잡도 표기법
시간 복잡도를 표현하는 방식은 보통 **빅오 표기법(Big O notation)**이다. 빅오 표기법은 최악의 경우 실행되는 시간에 대한 상한선을 나타낸다.

O(1) - 상수 시간: 입력 크기에 관계없이 항상 일정한 시간이 소요

예시: 배열의 첫 번째 원소에 접근하기
특징: 가장 빠른 시간 복잡도.
<BR>
O(log n) - 로그 시간: 입력 크기가 두 배로 늘어날 때 실행 시간이 일정 비율로 증가

예시: 이진 탐색(Binary Search)
특징: 로그 시간 복잡도는 대규모 데이터에서 매우 효율적
<BR>
O(n) - 선형 시간: 입력 크기에 비례하여 실행 시간이 증가

예시: 배열을 순차적으로 탐색하기
특징: 입력 데이터 크기에 비례해 시간이 늘어나지만, 로그 시간보다는 느림
<BR>
O(n log n) - 선형 로그 시간: 입력 크기와 로그 시간의 곱으로 실행 시간이 증가

예시: 퀵 정렬(Quick Sort), 병합 정렬(Merge Sort)
특징: 매우 효율적인 알고리즘들이 자주 사용
<BR>
O(n^2) - 이차 시간: 입력 크기가 두 배로 늘어나면 실행 시간이 네 배로 증가

예시: 버블 정렬(Bubble Sort), 삽입 정렬(Insertion Sort)
특징: 일반적으로 비효율적인 알고리즘이 많다.
<BR>
O(2^n) - 지수 시간: 입력 크기가 두 배로 늘어날 때 실행 시간이 지수적으로 증가

예시: 피보나치 수열을 재귀적으로 계산하기
특징: 입력 크기가 매우 커지면 실행 시간이 급격히 증가
## 3. 시간 복잡도 분석의 중요성
시간 복잡도를 분석하는 이유는 알고리즘이 해결하려는 문제의 크기가 커질수록 효율성이 중요해지기 때문이다. 예를 들어, 수백만 개의 데이터가 주어졌을 때, O(n^2) 시간 복잡도를 가지는 알고리즘은 실행 시간이 너무 길어질 수 있다. 반면 O(n log n) 시간 복잡도를 가지는 알고리즘은 대규모 데이터에서도 빠르게 동작한다.

## 4. 시간 복잡도 예시
### 1. O(1) 예시
배열에서 특정 인덱스의 값을 찾는 작업은 항상 일정한 시간에 이루어진다. 예를 들어, 배열에서 인덱스 5의 값을 찾는 작업은 입력 크기와 관계없이 항상 일정한 시간만 소요된다.

```python
def get_element(arr, index):
    return arr[index]  # 항상 일정한 시간에 실행됨
```
### 2. O(n) 예시
배열의 모든 원소를 순차적으로 탐색하는 알고리즘은 입력 크기에 비례하여 시간이 증가한다. 예를 들어, 배열에서 값을 찾을 때 배열을 처음부터 끝까지 탐색하는 경우가 해당된다.

```python
def find_value(arr, target):
    for item in arr:
        if item == target:
            return True
    return False  # O(n) 시간 복잡도
```
### 3. O(n^2) 예시
이차원 배열을 처리하거나 두 개의 배열을 비교하는 알고리즘은 O(n^2) 시간 복잡도를 가질 수 있다. 예를 들어, 버블 정렬은 두 개의 원소를 비교하면서 반복적으로 정렬을 수행한다.

```python
def bubble_sort(arr):
    for i in range(len(arr)):
        for j in range(len(arr) - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]  # O(n^2) 시간 복잡도
```
## 5. 시간 복잡도 최적화
시간 복잡도를 최적화하는 방법은 크게 두 가지다:

**알고리즘 변경:** 더 효율적인 알고리즘으로 변경하는 것. 예를 들어, 버블 정렬을 퀵 정렬로 바꾸는 것처럼.
**구현 최적화:** 알고리즘을 구현하는 과정에서 불필요한 연산을 줄이는 방법. 예를 들어, 이미 정렬된 배열에서 다시 정렬을 하지 않도록 하는 방법이다.